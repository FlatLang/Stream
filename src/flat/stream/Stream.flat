package flat/stream

import flat/async/Async
import flat/datastruct
import flat/datastruct/list
import flat/log/Logger

class<Type> {
  static Logger log = Logger(Stream.class)

  visible Type first => iterator.hasNext ? iterator.stepNext : null
  visible Type last {
    get {
      var Type value

      while (iterator.hasNext) {
        value = iterator.stepNext
      }

      return value
    }
  }
  visible Type firstNonNull => filter({ _ != null }).first
  visible Type lastNonNull {
    get {
      var Type value

      while (iterator.hasNext) {
        if (let x = iterator.stepNext) {
          value = x
        }
      }

      return value
    }
  }
  visible Int count {
    get {
      var Int value = 0

      for (x in iterator) {
        value++
      }

      return value
    }
  }

  public construct(visible Iterator<Type> iterator) {}

  public map<Out>(mapFunc(Type) -> Out) =>
    Stream<Out>(MapIterator<Type, Out>(iterator, mapFunc))

  public mapNotNull<Out>(mapFunc(Type) -> Out) =>
    map(mapFunc).filter({ _ != null })

  public peek(func(Type)) =>
    Stream<Out>(PeekIterator<Type, Out>(iterator, func))

  public flatMap<Out>(mapFunc(Type) -> Stream<Out>) =>
    Stream<Out>(FlatMapIterator<Type, Out>(iterator, mapFunc))

  public filter(filterFunc(Type) -> Bool) =>
    Stream<Type>(FilterIterator<Type>(iterator, filterFunc))

  public filterNot(filterFunc(Type) -> Bool) =>
    Stream<Type>(FilterNotIterator<Type>(iterator, filterFunc))

  public skip(Int count) =>
    Stream<Type>(SkipIterator<Type>(iterator, count))

  public take(Int count) =>
    Stream<Type>(TakeIterator<Type>(iterator, count))

  public firstWhere(func(Type) -> Bool) -> Type =>
    filter(func).first

  public any(func(Type) -> Bool) =>
    filter(func).iterator.hasNext

  public all(func(Type) -> Bool) =>
    !filterNot(func).iterator.hasNext

  public none(func(Type) -> Bool) =>
    !filter(func).iterator.hasNext

  public count(func(Type) -> Bool) =>
    filter(func).count

  public toArray() -> Type[] {
    let array = Type[]

    for (value in iterator) {
      array.add(value)
    }

    return array
  }

  public toSet() -> HashSet<Type> {
    let set = HashSet<Type>()

    for (value in iterator) {
      set.add(value)
    }

    return set
  }

  public forEach(func(Type)) {
    for (value in iterator) {
      func(value)
    }
  }

  public async forEachParallel(async func(Type), Int maxParallel = -1) {
    Async.all(toArray(), { func(_) }, maxParallel)
  }
}
