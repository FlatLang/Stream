package flat/stream

import flat/datastruct
import flat/datastruct/list
import flat/log/Logger

class<Type> {
  static Logger log = Logger(Stream.class)

  visible Type first => iterator.hasNext ? iterator.stepNext : null
  visible Type firstNonNull => filter({ _ != null }).first

  public construct(visible Iterator<Type> iterator) {}

  public map<Out>(mapFunc(Type) -> Out) => StreamMap<Out>(iterator, mapFunc)

  public mapNotNull<Out>(mapFunc(Type) -> Out) => StreamMap<Out>(iterator, mapFunc).filter({ _ != null })

  public flatMap<Out>(mapFunc(Type) -> Stream<Out>) => StreamFlatMap<Out>(iterator, mapFunc)

  public filter(filterFunc(Type) -> Bool) => StreamFilter<Type>(iterator, filterFunc)

  public skip(Int count) => StreamSkip<Type>(iterator, count)

  public take(Int count) => StreamTake<Type>(iterator, count)

  public firstWhere(func(Type) -> Bool) -> Type => StreamFirstWhere(iterator, func).first

  public toArray() -> Type[] {
    let array = Type[]

    for (value in iterator) {
      array.add(value)
    }

    return array
  }
}
