package flat/stream

import flat/datastruct
import flat/datastruct/list
import flat/log/Logger

class<Type> {
  static Logger log = Logger(Stream.class)

  visible Type first => iterator.hasNext ? iterator.stepNext : null
  visible Type firstNonNull => filter({ _ != null }).first
  visible Int count {
    get {
      var Int value = 0

      for (x in iterator) {
        value++
      }

      return value
    }
  }

  public construct(visible Iterator<Type> iterator) {}

  public map<Out>(mapFunc(Type) -> Out) =>
    Stream<Out>(MapIterator<Type, Out>(iterator, mapFunc))

  public mapNotNull<Out>(mapFunc(Type) -> Out) =>
    map(mapFunc).filter({ _ != null })

  public flatMap<Out>(mapFunc(Type) -> Stream<Out>) =>
    Stream<Out>(FlatMapIterator<Type, Out>(iterator, mapFunc))

  public filter(filterFunc(Type) -> Bool) =>
    Stream<Type>(FilterIterator<Type>(iterator, filterFunc))

  public filterNot(filterFunc(Type) -> Bool) =>
    Stream<Type>(FilterNotIterator<Type>(iterator, filterFunc))

  public skip(Int count) =>
    Stream<Type>(SkipIterator<Type>(iterator, count))

  public take(Int count) =>
    Stream<Type>(TakeIterator<Type>(iterator, count))

  public firstWhere(func(Type) -> Bool) -> Type =>
    filter(func).first

  public any(func(Type) -> Bool) =>
    filter(func).iterator.hasNext

  public all(func(Type) -> Bool) =>
    !filterNot(func).iterator.hasNext

  public count(func(Type) -> Bool) =>
    filter(func).count

  public toArray() -> Type[] {
    let array = Type[]

    for (value in iterator) {
      array.add(value)
    }

    return array
  }
}
